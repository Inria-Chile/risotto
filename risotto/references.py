# AUTOGENERATED! DO NOT EDIT! File to edit: 01_references.ipynb (unless otherwise specified).

__all__ = ['get_id_paths_dicts', 'BasePaper', 'PDFPaper', 'PMCPaper', 'load_papers_from_metadata_file',
           'paper_as_markdown', 'build_papers_reference_graph']

# Cell
# removing ugly pandas warning in macOS
import warnings
warnings.filterwarnings("ignore", ".*lzma.*")

# Cell
import pandas as pd
import numpy as np
import networkx as nx

from fastprogress.fastprogress import progress_bar

from pathlib import Path

import json
import random
import os

import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid')
sns.set_context('notebook')

# Cell
def get_id_paths_dicts(cls, cord19_dataset_folder):
    """
    This function builds the dictionaries whose keys are identifiers
    of some kind of papers (PDF or PMC) and whose values are the paths to
    associated files.
    """
    all_files = {}
    for root, folders, files in os.walk(cord19_dataset_folder):
        num_folders = len(folders)
        num_files = len(files)
        if cls in root and num_folders == 0 and num_files > 0:
            for file_name in files:
                _id = file_name.split(".")[0]
                all_files[_id] = os.path.join(root, file_name)
    return all_files

# Cell
class BasePaper:
    def __init__(self, metadata_row, file_path):
        self._metadata_row = metadata_row
        self._file_path = file_path
        self._file_contents = self._load_json_contents(file_path)

        self._referenced_by = []
        self._references = []

    def __getstate__(self):
        """
        Avoid RecursionErrors by not pickling references.
        """
        state = self.__dict__.copy()
        del state["_referenced_by"]
        del state["_references"]
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)
        self._referenced_by = []
        self._references = []

    @staticmethod
    def _load_json_contents(path):
        with open(path) as file:
            contents = json.load(file)
        return contents

    @property
    def title(self):
        return self._metadata_row["title"]

    @property
    def authors(self):
        return self._metadata_row["authors"]

    @property
    def publish_time(self):
        return self._metadata_row["publish_time"]

    @property
    def abstract(self):
        return self._metadata_row["abstract"]

    @property
    def bib_entries(self):
        return self._file_contents["bib_entries"]

    @property
    def doi(self):
        return self._metadata_row["doi"]

    @property
    def url(self):
        return self._metadata_row["url"]

    def register_reference(self, reference):
        self._references.append(reference)
        reference.register_referenced(self)

    def register_referenced(self, referenced):
        self._referenced_by.append(referenced)

# Cell
class PDFPaper(BasePaper):
    pass

# Cell
class PMCPaper(BasePaper):
    pass

# Cell
def load_papers_from_metadata_file(cord19_dataset_folder):
    'Loads papers by reading the `metadata.csv` file present in the dataset.'
    metadata_df = pd.read_csv(f"{cord19_dataset_folder}/metadata.csv",
                              index_col="cord_uid")
    pdf_dict = get_id_paths_dicts("pdf", cord19_dataset_folder)
    pmc_dict = get_id_paths_dicts("pmc", cord19_dataset_folder)

    papers = []
    not_found = []
    for idx, row in progress_bar(metadata_df.iterrows(),
                                 total=len(metadata_df)):
        pmc_id = row["pmcid"]
        shas = row["sha"]
        paper = None

        if pmc_id in pmc_dict:
            pmc_path = pmc_dict[pmc_id]
            paper = PMCPaper(row, pmc_path)

        if paper is None and pd.notna(shas):
            shas_splitted = shas.split("; ")
            for sha in shas_splitted:
                if sha in pdf_dict:
                    pdf_path = pdf_dict[sha]
                    paper = PDFPaper(row, pdf_path)
                    break

        if paper is None and (row["has_pdf_parse"]
                              or row["has_pmc_xml_parse"]):
            not_found.append(idx)
        if paper is not None:
            papers.append(paper)

    return papers, not_found

# Cell
def paper_as_markdown(paper):
    from IPython.display import display, Markdown
    res = f"""
- **Title:** {paper.title}
- **Authors:** {paper.authors}
- **Publish date/time:** {paper.publish_time}
- **Linked references:** {len(paper._references)}
- **Linked referenced by:** {len(paper._referenced_by)}
- **Abstract:** {paper.abstract}"""
    display(Markdown(res))

# Cell
def build_papers_reference_graph(papers):
    G = nx.DiGraph()

    # First add the nodes
    for paper in papers:
        G.add_node(paper)

    # Then, add the links
    for paper in papers:
        for referenced_paper in paper._references:
            G.add_edge(paper, referenced_paper)

    return G